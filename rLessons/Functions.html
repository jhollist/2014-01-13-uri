<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Functions, Control Structures and Documentation</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Functions, Control Structures and Documentation</h1>

<p><em>Note: This lesson is mostly from Karthik Ram&#39;s <a href="https://github.com/swcarpentry/2013-10-09-canberra">material from the Canberra Software Carpentry R Bootcamp</a>.  Anything good is there becuase of Karthik.  Mistakes are all mine.</em></p>

<h1>Lesson Index:</h1>

<ul>
<li><a href="#functions">Functions</a></li>
<li><a href="#control-strucutres">Control Structures</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#function-exercise">Exercise</a></li>
</ul>

<h1>Functions</h1>

<p>Functions represent one of the most powerful features of the R language. By creating functions, you can go past just using what others have written and create your own.</p>

<p>After a while operations at the interactive prompt are not enough. You have special operations that need to be grouped together. That&#39;s when you&#39;ll need to write functions.</p>

<ul>
<li>Basic of how to write functions</li>
<li>Lexical scoping and scoping rules</li>
<li>Example</li>
</ul>

<p>Functions are created using the <code>function()</code> directive.
They are stored as any other R object.  They are of class &ldquo;function&rdquo;</p>

<p><strong>Basic syntax</strong></p>

<pre><code>func &lt;- function(&lt;take some input&gt;)  {
    # run a whole bunch of your code
}
</code></pre>

<p>Functions are first class objects. Treat them the same way as any other objects. This means you can pass them to other functions (as you would do with say vectors). Very useful feature for statistical analyses. We can also nest functions inside each other.</p>

<p>Return value is the very last R expression to be evaluated. No special expression for returning although you can use return()</p>

<p>Functions have named arguments and these can have default values. Arguments used inside a function definition are called formal arguments.</p>

<p>use <code>formals()</code> to see what they are.</p>

<p>Not every function makes use of all formal arguments.</p>

<p>Function arguments can be missing or might just use default values. Formal arguments are included in the function definition.</p>

<p>If a function has 10 arguments, you don&#39;t have to specify all of them. </p>

<p>R function arguments can be matched positionally or by name.</p>

<pre><code class="r">args(sd)
</code></pre>

<p>Takes x, a vector of data. 
Default is <code>na.rm</code> is false.
So you don&#39;t have to do anything.</p>

<pre><code class="r">dat &lt;- rnorm(1000)
sd(dat)  # Matched positionally
sd(x = dat)  # matched by name
sd(x = dat, na.rm = FALSE)
# When naming you can switch them but not recommended
sd(na.rm = FALSE, dat)
</code></pre>

<p>Even though it&#39;s allowed, don&#39;t switch positions on names.</p>

<p>See </p>

<pre><code class="r">args(lm)
</code></pre>

<p>It&#39;s good to name arguments when you have a long list to work through. Arguments can also be partially matched.</p>

<pre><code class="r">add &lt;- function(x = 1, y = 2) {
    x + y
}
</code></pre>

<p>R does what&#39;s known as lazy evaluation. Arguments to functions are lazily evaluated. Common model in many languages. Only evaluated as they are needed.</p>

<pre><code class="r">add &lt;- function(a, b) {
    a^2
}
</code></pre>

<p>The function call never uses b. So calling <code>f(10)</code> will not produce an error because <code>a</code> got positionally matched.</p>

<p>Another example of lazy evaluation</p>

<pre><code class="r">add &lt;- function(a, b) {
    print(a^2)
    print(b^2)
}
</code></pre>

<p><code>add(10)</code> will work until it reaches a point where the function will break.</p>

<p><strong>The three dot operator.</strong></p>

<p><code>...</code> are used when extending another function and you don&#39;t want to copy the entire list of arguments from the original function.</p>

<p>Also useful when the number of arguments cannot be known in advance. For example <code>paste()</code> takes a variable number of arguments. Function does not know how many things it&#39;s going to paste together.</p>

<h2>Writing functions in R</h2>

<p>If you have to repeat the same few lines of code more than once, then you really need to write a function. Functions are a fundamental building block of R. You use them all the time in R and it&#39;s not that much harder to string functions together (or write entirely new ones from scratch) to do more.</p>

<ul>
<li>R functions are objects just like anything else. </li>
<li>By default, R function arguments are lazy - they&#39;re only evaluated if they&#39;re actually used:</li>
<li>Every call on a R object is almost always a function call.</li>
</ul>

<h3>Basic components of a function</h3>

<ul>
<li>The <code>body()</code>, the code inside the function.</li>
<li>The <code>formals()</code>, the &ldquo;formal&rdquo; argument list, which controls how you can call the function.</li>
<li>The <code>environment()</code> which determines how variables referred to inside the function are found.</li>
<li><code>args()</code> to list arguments.</li>
</ul>

<pre><code class="r">f &lt;- function(x) x
f

formals(f)

environment(f)
</code></pre>

<p><strong>Question: How do we delete this function from our environment?</strong></p>

<h2>More on environments</h2>

<p>Variables defined inside functions exist in a different environment than the global environment. However, if a function is not defined inside one, it will look one level above.</p>

<p>For example.</p>

<pre><code>x &lt;- 2
g &lt;- function() { 
  y &lt;- 1
  c(x, y)
}  
g()
rm(x, g)
</code></pre>

<p>Same rule applies for nested functions.</p>

<p>A first useful function.</p>

<pre><code class="r">first &lt;- function(x, y) {
    z &lt;- x + y
    return(z)
}
</code></pre>

<pre><code class="r">add &lt;- function(a, b) {
    return(a + b)
}

add(c(1, 2, 3, 4), 1)
</code></pre>

<h2>What does this function return?</h2>

<pre><code class="r">x &lt;- 5
f &lt;- function() {
    y &lt;- 10
    c(x = x, y = y)
}
f()
</code></pre>

<h2>What does this function return?</h2>

<pre><code class="r">x &lt;- 5
g &lt;- function() {
    x &lt;- 20
    y &lt;- 10
    c(x = x, y = y)
}
g()
</code></pre>

<h2>What does this function return??</h2>

<pre><code class="r">x &lt;- 5
h &lt;- function() {
    y &lt;- 10
    i &lt;- function() {
        z &lt;- 20
        c(x = x, y = y, z = z)
    }
    i()
}
h()
</code></pre>

<h2>Functions with pre defined values</h2>

<pre><code class="r">temp &lt;- function(a = 1, b = 2) {
    return(a + b)
}
</code></pre>

<h2>Functions usually return the last value it computed</h2>

<pre><code>f &lt;- function(x) {
  if (x &lt; 10) {
    0
  } else {
    10
  }
}
f(5)
f(15)
</code></pre>

<h1>Control Structures</h1>

<p>These allow you to control the flow of execution of a script typically inside of a function.
Common ones include:</p>

<ul>
<li>if, else</li>
<li>for</li>
<li>while</li>
<li>repeat</li>
<li>break</li>
<li>next</li>
<li>return</li>
</ul>

<p>We don&#39;t use these while working with R interactively but rather inside functions. </p>

<h2>If/else</h2>

<pre><code class="r">if(condition) {
    # do something 
} else { 
    # do something else
    }
}
</code></pre>

<p>e.g. </p>

<pre><code class="r">x &lt;- 1:15
if (sample(x, 1) &lt;= 10) {
    print(&quot;x is less than 10&quot;)
} else {
    print(&quot;x is greater than 10&quot;)
}
</code></pre>

<p><strong>Shorthand for ifelse</strong></p>

<p><code>ifelse(sample(x, 1) &lt;10, &quot;x less than 10&quot;, &quot;x greater than 10&quot;)</code></p>

<p>Other valid ways of writing if/else</p>

<pre><code class="r">if (sample(x, 1) &lt; 10) {
    y &lt;- 5
} else {
    y &lt;- 0
}
</code></pre>

<pre><code class="r">y &lt;- if (sample(x, 1) &lt; 10) {
    5
} else {
    0
}
</code></pre>

<h2>for</h2>

<p>For loops work on an iterable variable and assign successive values till the end of a sequence.</p>

<pre><code class="r">for (i in 1:10) {
    print(i)
}
</code></pre>

<pre><code class="r">x &lt;- c(&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;strawberries&quot;)

for (i in x) {
    print(x[i])
}

for (i in 1:4) {
    print(x[i])
}

for (i in seq(x)) {
    print(x[i])
}

for (i in 1:4) print(x[i])
</code></pre>

<p>Nested loops</p>

<pre><code class="r">m &lt;- matrix(1:10, 2)
for (i in seq(nrow(m))) {
    for (j in seq(ncol(m))) {
        print(m[i, j])
    }
}
</code></pre>

<h2>While</h2>

<pre><code>i &lt;- 1
while(i &lt; 10) {
    print(i)
    i &lt;- i + 1
}
</code></pre>

<p>Be sure there is a way to exit out of a while loop.</p>

<h2>Repeat and break</h2>

<pre><code class="r">repeat {
    # simulations; generate some value have an expectation if within some range,
    # then exit the loop
    if ((value - expectation) &lt;= threshold) {
        break
    }
}
</code></pre>

<h2>Next</h2>

<pre><code class="r">for (i in 1:20) {
    if (i%%2 == 1) {
        next
    } else {
        print(i)
    }
}
</code></pre>

<p>This loop will only print even numbers and skip over odd numbers. In the afternoon we&#39;ll learn other functions that will help us avoid these types of slow control flows as much as possible (mostly the while and for loops).</p>

<h1>Documentation</h1>

<p>Anyone who has worked with computers at any level for any period of time will attest to the fact that keeping track of your workflow and understanding what was done and why gets problematic quickly.  Tomorrow we will introduce a solution of this that deals with managing multiple versions.  </p>

<p>But, at an even more basic level than versioning, is the issue of being able to read a piece of code and understand what it is doing.  The primary solution for creating understandable code is documentation and you already have been doing some of this if you have been using comment tags (<code>#</code>).  </p>

<p>These are simple to implement, can be placed anywhere in your code.  </p>

<p>For instance:</p>

<pre><code class="r"># Here is an example of a simple comment This function, takes and argment
# and prints it to the screen
x &lt;- function(arg) {
    print(arg)  # Printing the arg
}

x(&quot;Documentation is cool!&quot;)

</code></pre>

<p>These simple comments are likely enought just for scripts, but as you begin to use functions it better to follow a more standard format.  One such format that is widely used in package development is <a href="http://roxygen.org">Roxygen</a>, a literate programming .  Its current implementation in R is with <code>roxygen2</code>.  It allows for simple documenting of code and easily converting that code into manual pages.  We won&#39;t go that far, but learning to document the basics with Roxygen style comments (<code>#&#39;</code>) and tags (<code>@</code>) will put you much closer to being able to develop packages.</p>

<p>Roxygen Comment and Tags</p>

<pre><code class="r">#&#39; This is an Roxygen comment!  Pretty difficult, eh?
#&#39; @param This is an Roxygen tag
</code></pre>

<p>So to use these to document a function would look like:</p>

<pre><code class="r">#&#39; My Simple Function
#&#39;
#&#39; This function takes an argument and prints it to the screen
#&#39; 
#&#39; @param args This is an input argument.  May be of any type
#&#39; 
#&#39; @return returns an object of the same type as the input.
#&#39;
#&#39; @export 
#&#39;
#&#39; @examples
#&#39; x(&#39;Roxygen style documentation is cooler&#39;)
#&#39; x(&#39;#&#39;&#39;&gt;&#39;#&#39;)

x &lt;- function(arg) {
    # You can still use regular comments, if you like.  This is probably a good
    # idea, too.
    return(arg)
}

x(&quot;Roxygen style documentation is cooler&quot;)
x(&quot;#&#39;&quot; &gt; &quot;#&quot;)
</code></pre>

<p>** note: <code>@export</code> and <code>@examples</code> are important for package development.  I only include them here to let you know there are many tags you can use **</p>

<p>So, while it takes a bit more time to document as you write, it will pay dividends in the future as your properly documented code will be</p>

<ul>
<li>Easier for you to understand when you come back to it later</li>
<li>Easier for others to understand</li>
<li><em>MUCH</em> easier to convert a collection of functions into a package</li>
</ul>

<p>To find out more, Hadley Wickham&#39;s <a href="http://adv-r.had.co.nz/Documenting-functions.html">Advanced R Programming</a> is a great resource.</p>

<h1>Function Exercise</h1>

<p>Continuing with our NLA example, this exercise will have you create several functions that work on that dataset.</p>

<ol>
<li><p>Create a function (with proper documentation, but no need to inclue <code>@export</code> or <code>@examples</code>) that takes a vector as input and returns it&#39;s mean.</p></li>
<li><p>Create another function (again with good documentation), that allows us to deal with <code>NA</code> values (hint: think <code>mean()&#39; and</code>&hellip;).</p></li>
<li><p>Create another function (do I have to say it?) that allows you to calculate the mean and standard deviation (hint: <code>sd()</code>) of the input and still deals with <code>NA</code>.  You will probably want to have a third argument in your function and will need to use a control structure from above.</p></li>
<li><p>Now use this function you have created to get mean and standard deviation of  two of the data columns in your NLA data frame you created earlier.  If you no longer have that in memory, you can use <code>read.csv()</code> and the .csv file you wrote to disk.</p></li>
</ol>

</body>

</html>

